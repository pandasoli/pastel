# -*- coding: utf-8 -*- #

PR include "../printing/task.a68" PR
PR include "../printing/note.a68" PR
PR include "../globals.a68" PR
PR include "../utils.a68" PR
PR include "../quick sort.a68" PR;

PROC show tasks = VOID: (

	PROC find task group = (INT id, [] GROUP groups) REF GROUP: (
		REF GROUP group := NIL;

		FOR i TO UPB groups DO
			IF includes(ids OF groups[i], id) THEN
				group := HEAP GROUP := groups[i];
				done
			FI
		OD;

		done: group
	);

	PROC print group = (STRING title, [] ITEM items, [] GROUP groups) VOID: (
		FLEX [0] INT printed in group;
		BOOL found sep := FALSE;
		INT i := 1;

		IF UPB title > 0 THEN
			printf(($l"      ╭ "g"[1m"gg"[m"l$, esc, title, esc));
			printf($"      │"l$)
		ELSE
			printf($"      ╭"l$)
		FI;

		WHILE i <= UPB items DO
			INT id := get item id(items[i]);
			BOOL has time := get item time(items[i]) :/=: REF TIME(NIL);

			# Skip items that are were printed in groups or it's all day and is in a group #
			WHILE includes(printed in group, id) ORF (NOT has time AND (find task group(id, groups) :/=: REF GROUP(NIL))) DO
				i +:= 1;
				id := get item id(items[i]);
				has time := get item time(items[i]) :/=: REF TIME(NIL);

				IF i > UPB items THEN
					done
				FI
			OD;

			# Add separator after no-time items #
			IF has time AND NOT found sep AND i > 1 THEN
				found sep := TRUE;
				printf($"      │"l$);

				IF i > 1 THEN
					CASE items[i - 1] IN
						(NOTE note):
							printf($"      │"l$),

						(TASK task): (
							BOOL has reason = reason OF task :/=: REF STRING(NIL);
							STRING description = (state OF task = canceled AND has reason | reason OF task | description OF task);

							IF UPB description = 0 THEN
								printf($"      │"l$)
							FI
						)
					ESAC
				FI
			FI;

			# print item #
			REF GROUP group = find task group(get item id(items[i]), groups);

			IF (group :/=: REF GROUP(NIL)) AND has time THEN
				FLEX [0] ITEM these items;

				FOR i TO UPB items DO
					IF includes(ids OF group, get item id(items[i])) THEN
						printed in group +:= get item id(items[i]);
						these items +:= items[i]
					FI
				OD;

				print group(title OF group, these items, ~);
				printf($"      │"l$)
			ELSE
				CASE items[i] IN
					(TASK v): print task(v),
					(NOTE v): print note(v)
				ESAC
			FI;

			i +:= 1
		OD;

		done:
		printf($"      ╰"ll$)
	);

	[] TASK tasks = get today tasks;
	[] NOTE notes = get today notes;
	[] GROUP groups = get today groups;

	FLEX [0] ITEM items;

	FOR i TO UPB tasks DO items +:= ITEM(tasks[i]) OD;
	FOR i TO UPB notes DO items +:= ITEM(notes[i]) OD;

	quick sort(items, 1, UPB items);
	print group("", items, groups)
)
