# -*- coding: utf-8 -*- #

PR include "../globals.a68" PR
PR include "../quick sort.a68" PR;

PROC remove = (REF INT argi) VOID: (
	STRING arg := get argv(argi +:= 1, "Expected index after 'remove'");
	INT index = TOINT arg;

	[] TASK tasks = get today tasks;
	[] NOTE notes = get today notes;
	FLEX [0] ITEM items;

	FOR i TO UPB tasks DO items +:= tasks[i] OD;
	FOR i TO UPB notes DO items +:= notes[i] OD;

	quick sort(items, 1, UPB items);

	IF index > UPB items THEN
		putf(stand error, ($g"[31m"gg"[m"ll$, esc, "There're not many items in today's list", esc));
		stop
	FI;

	ITEM item = items[index];

	PROC process = (ITEM item, PROC (PROC (ITEM) VOID) VOID get all, PROC (ITEM) STRING encode) VOID: (
		INT id = get item id(item);

		get all((ITEM i) VOID:
			IF get item id(i) /= id THEN
				STRING str = encode(i);
				append file("./new.csv", str)
			FI
		)
	);

	CASE item IN
		(NOTE note):
			BEGIN
				append file("./new.csv", note csv header);

				process(
					item,
					(PROC (ITEM) VOID callback) VOID:
						get all notes((NOTE n) VOID:
							callback(ITEM(n))
						),
					(ITEM item) STRING:
						CASE item IN
							(NOTE note): note to csv(note)
						ESAC
				);

				move file("./new.csv", notes data path)
			END,

		(TASK task):
			BEGIN
				append file("./new.csv", task csv header);

				process(
					item,
					(PROC (ITEM) VOID callback) VOID:
						get all tasks((TASK t) VOID:
							callback(ITEM(t))
						),
					(ITEM item) STRING:
						CASE item IN
							(TASK task): task to csv(task)
						ESAC
				);

				move file("./new.csv", tasks data path)
			END
	ESAC
)
