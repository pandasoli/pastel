# -*- coding: utf-8 -*- #

PR include "types.a68" PR
PR include "csv.a68" PR

OP TOINT = (STRING str) INT: (
	INT n := 0, sign := 1;
	FOR i TO UPB str WHILE sign /= 0 DO
		IF is digit(str[i]) THEN n := n * 10 + ABS str[i] - ABS "0"
		ELIF i = 1 AND str[i] = "-" THEN sign := -1
		ELIF i /= 1 OR str[i] /= "+" THEN sign := 0
		FI
	OD;
	n * sign
);

PROC str to date = (STRING str) DATE: (
	IF UPB str /= 10 OR
		 str[3] /= "/" OR str[6] /= "/"
	THEN
		printf(($g" cannot be coerced to DATE"l$, str));
		stop
	FI;

	DATE(
		TOINT (str[1] + str[2]),
		TOINT (str[4] + str[5]),
		TOINT (str[7] + str[8] + str[9] + str[10])
	)
);

PROC str to time = (STRING str) TIME: (
	IF UPB str /= 5 OR str[3] /= ":" THEN
		printf(($g" cannot be coerced to TIME"l$, str));
		stop
	FI;

	TIME(TOINT (str[1] + str[2]), TOINT (str[4] + str[5]))
);

PROC csv to task = (FLEXCSVFIELDS fields) TASK: (
	REF TIMES time := (fields[8] = "" | NIL |
		LOC TIMES := (
			# start # str to time(fields[8]),
			# finish # (fields[9] = "" | NIL |
				LOC TIME := str to time(fields[9])
			)
		)
	);

	TASK(
		# id # TOINT fields[1],
		# title # fields[2],
		# description # fields[3],
		# reason # (fields[4] = "" | NIL | fields[4]),
		# in_group # fields[5] = "T",
		# state # TOINT fields[6],
		# date # str to date(fields[7]),
		# time # time,
		# repeatition # TOINT fields[10]
	)
);

PROC task to csv = (TASK task) STRING: (
	BOOL has time = time OF task :=: REF TIMES(NIL);

	[] STRING fields = (
		# id # whole(id OF task, 0),
		# title # """" + title OF task + """",
		# description # """" + description OF task + """",
		# reason # (reason OF task :=: REF STRING(NIL) | "" | """" + reason OF task + """"),
		# in_group # (in_group OF task | "T" | "F"),
		# state # whole(state OF task, 0),
		# date # REPR date OF task,
		# start # (has time | "" | REPR start OF time OF task),
		# finish # (has time | "" | (finish OF time OF task :=: REF TIME(NIL) | "" | REPR finish OF time OF task)),
		# repeatition # whole(repeatition OF task, 0)
	);

	STRING reg := "";

	FOR i TO UPB fields DO
		reg +:= fields[i] + (i < UPB fields | "," | "")
	OD;

	reg
);

OP REPR = (TIME time) STRING: 
	(hours OF time <= 9 | "0" | "") + whole(hours OF time, 0) + ":" +
	(minutes OF time <= 9 | "0" | "") + whole(minutes OF time, 0);

OP REPR = (DATE date) STRING: 
	(month OF date <= 9 | "0" | "") + whole(month OF date, 0) + "/" +
	(day OF date <= 9 | "0" | "") + whole(day OF date, 0) + "/" +
	whole(year OF date, 0);

OP = = (DATE a, b) BOOL:
	day OF a = day OF b AND
	month OF a = month OF b AND
	year OF a = year OF b;

OP +:= = (REF FLEX [] TASK in out, TASK item) VOID: (
	[UPB in out + 1] TASK new;
	new[:UPB in out] := in out;
	new[UPB new] := item;
	in out := new
);

OP +:= = (REF FLEX [] STRING in out, STRING item) REF FLEX [] STRING: (
	[UPB in out + 1] STRING new;
	new[:UPB in out] := in out;
	new[UPB new] := item;
	in out := new
);

PROC strchr = (STRING str, CHAR ch) INT: (
	INT pos := UPB str;

	FOR i TO UPB str DO
		IF str[i] = ch THEN
			pos := i;
			done
		FI
	OD;

	done: pos
);

PROC wrap text = (STRING text, INT width) [] STRING: (
	FLEX [0] STRING parts;
	STRING part;
	INT text i := 1;

	WHILE text i < UPB text DO
		INT
			next space = strchr(text[text i:], " "),
			next dash = strchr(text[text i:], "-");

		INT next := (next space < next dash | next space | next dash);

		IF UPB part + next > width THEN
			IF next > width THEN
				INT len = width - UPB part - 1;
				parts +:= part + text[text i:][:len] + "-";
				next := len;
				part := ""
			ELSE
				parts +:= part;

				IF part[UPB part] = " " THEN
					parts[UPB parts] := part[:UPB part - 1]
				FI;
				part := text[text i:][:next]
			FI
		ELSE
			part +:= text[text i:][:next]
		FI;

		text i +:= next
	OD;

	parts +:= part
)
