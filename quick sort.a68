# -*- coding: utf-8 -*- #

PR include "types/task.a68" PR
PR include "types/note.a68" PR;

MODE SORTITEMS = UNION (TASK, NOTE);

OP +:= = (REF FLEX [] SORTITEMS in out, SORTITEMS item) VOID: (
	[UPB in out + 1] SORTITEMS new;
	new[:UPB in out] := in out;
	new[UPB new] := item;
	in out := new
);

PROC bigger = (SORTITEMS a, b) BOOL: (
	PROC get time = (SORTITEMS v) REF TIME:
		CASE v IN
			(TASK v): start OF time OF v,
			(NOTE v): time OF v
		ESAC;

	PROC get date = (SORTITEMS v) DATE:
		CASE v IN
			(TASK v): date OF v,
			(NOTE v): date OF v
		ESAC;

	DATE
		a date = get date(a),
		b date = get date(b);

	REF TIME
		a time = get time(a),
		b time = get time(b);

	BOOL
		a all day = a time :=: REF TIME(NIL),
		b all day = b time :=: REF TIME(NIL);

		IF a all day THEN TRUE # a #
	ELIF b all day THEN FALSE # b #
	ELSE
		INT
			a hours   := hours   OF a time,
			b hours   := hours   OF b time,
			a minutes := minutes OF a time,
			b minutes := minutes OF b time;

		a hours := (a hours = 0 | 24 | a hours);
		b hours := (b hours = 0 | 24 | b hours);

		IF a hours = b hours THEN
			IF a minutes < b minutes THEN TRUE # a #
			ELSE FALSE # b #
			FI
		ELIF a hours < b hours THEN TRUE # a #
		ELSE FALSE # b #
		FI
	FI
);

PROC swap = (REF [] SORTITEMS arr, INT i, j) VOID: (
	SORTITEMS temp = arr[i];
	arr[i] := arr[j];
	arr[j] := temp
);

PROC partition = (REF [] SORTITEMS arr, INT low, high) INT: (
	SORTITEMS pivot = arr[high];
	INT i := low - 1;

	FOR j FROM low TO high - 1 DO
		IF bigger(arr[j], pivot) THEN
			i +:= 1;
			swap(arr, i, j)
		FI
	OD;

  swap(arr, i + 1, high);
  i + 1
);

PROC quick sort = (REF [] SORTITEMS arr, INT low, high) VOID:
	IF low < high THEN
		INT pi = partition(arr, low, high);

		quick sort(arr, low, pi - 1);
		quick sort(arr, pi + 1, high)
	FI
