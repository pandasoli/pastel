# -*- coding: utf-8 -*- #

PR include "utils.a68" PR

OP TOINT = (STRING str) INT: (
	INT n := 0, sign := 1;

	FOR i TO UPB str WHILE sign /= 0 DO
		IF is digit(str[i]) THEN n := n * 10 + ABS str[i] - ABS "0"
		ELIF i = 1 AND str[i] = "-" THEN sign := -1
		ELIF i /= 1 OR str[i] /= "+" THEN sign := 0
		FI
	OD;

	n * sign
);

PROC center text = (STRING str, INT w) STRING: (
	STRING res := str;
	INT
		rest = w - UPB str,
		part = ENTIER (rest / 2),
		missing = rest MOD 2;

	TO part DO res := " " + res + " " OD;
	IF missing = 1 THEN res := res + " " FI;

	res
);

PROC join = ([] STRING list, STRING delim) STRING: (
	STRING res;

	FOR i TO UPB list DO
		res +:= list[i] + (i < UPB list | delim | "")
	OD;

	res
);

PROC sh scape = (STRING str, CHAR ch) STRING: (
	STRING text := str;
	INT text len := UPB text, i := 1;

	WHILE i <= text len DO
		IF text[i] = ch THEN
			text := text[:i - 1] + "\" + text[i:];
			text len +:= 1;
			i +:= 1
		FI;

		i +:= 1
	OD;

	text
);

PROC wrap text = (STRING str, INT w) []STRING: (
	FLEX [0] STRING lines;
	STRING line := "", word := "";

	FOR i TO UPB str DO
		CHAR ch = str[i];

		IF ch = " " THEN
			IF UPB word > 0 THEN
				# Check if we can add this word to current line #
				IF UPB line = 0 THEN
					line := word
				ELIF UPB line + 1 + UPB word <= w THEN
					line +:= " " + word
				ELSE
					# Can't fit, push current line and start new one #
					lines +:= line;
					line := word
				FI;

				word := ""
			FI
		ELSE
			word +:= ch
		FI;

		# Handle case where a single word exceeds the width #
		IF UPB word >= w THEN
			IF UPB line > 0 THEN
				lines +:= line;
				line := ""
			FI;

			# Break the long word (since it exceeds width) #
			WHILE UPB word >= w DO
				lines +:= word[:w];
				word := word[w + 1:]
			OD
		FI
	OD;

	# Add any remaining word #
	IF UPB word > 0 THEN
		IF UPB line = 0 THEN
			line := word
		ELIF UPB line + 1 + UPB word <= w THEN
			line +:= " " + word
		ELSE
			lines +:= line;
			line := word
		FI
	FI;

	IF UPB line > 0 THEN
		lines +:= line
	FI;

	lines
)
